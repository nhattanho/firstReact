+ React likes an external library of JS which using new featurs of JS called ES6

+ React-dom is a rendering to convert components in React to a real DOM or insert the code into html file
import ReactDOM from 'react-dom';
ReactDOM.render(app, document.querySelector('#app')); // checking in the index.htm where the element
//having the id is app and insert this part by function app which has been rendered already.

+ import React from 'react'; //it is library supporting to write the xml in javascript <=> JSX

+ Babel is a JS pre-processor to compile the code of React to code which can run successfully on all Browsers

+ES6 Modules helps us separate the project to several files/modules ==> easier to manage and mantain the code
==> However, the problem is browsers do not really support this features, so we have to bundle these modules
become a single file ==> using Webpack to bundle modules.

+ "react-scripts": "3.4.1" //Don't worry about Webpack and babel

+ "start": "react-scripts start",
  "build": "react-scripts build", ==> all code from source folder will be build and located in build folder used by Browsers
  "test": "react-scripts test",
  "eject": "react-scripts eject" ==> take out all of file hidden from us included scripts and config folder

+ Public folder: all files where the Browser needs

+ Src folder: the code of application 

+ Package.json: save all information of Application

+ <p>{this.state.string}<code>src/App.js</code> and save to reload.</p> ==> in xml, using {}, we can write
JS inside it

+ In xml: <header className="App-header"> | <button onClick={()=>{ this.setState({string: 'honhattan'})}}>Change</button>
In html: <header class="App-header">    |   <button onclick={()=>{ this.setState({string: 'honhattan'})}}>Change</button>

+ import React, {Component} from 'react' ==> class App extends Component {}
Or import React from 'react' ==> class App extends React.Component {}

+ In XML: combine Js and html==> if we want to add js code, it has to be in {}, and for html, html's code
has to be in (). If we use {}, and inside is not a js => syntax error. Example:
export const CardList = (props) => {
    (
        <div className='cardlist'> 
            {props.monsters.map( ele => 
                (<h1>{ele.name}</h1>)
            )} 
        </div>
    )
};
==> wrong, because inside{} is a () which used for html, so the right code has to be:
export const CardList = (props) => {
    return ( //==>return is a command in js
        <div className='cardlist'> 
            {props.monsters.map( ele => 
                (<h1>{ele.name}</h1>)
            )} 
        </div>
    );
};

==> Or we can use the new feature of ES6 like:
export const CardList = (props) =>
    ( //==>return is a command in js
        <div className='cardlist'> 
            {props.monsters.map( ele => 
                (<h1>{ele.name}</h1>)
            )} 
        </div>
    );
}; // it automatically return a value which in this case is a (html)

+ Each props should have an unique key, example:
<Card key={monster.id} monster={monster.name}> </Card>

+ We have the example of designer's graph in React:

                     App.js - Parent Node
                        /       \
                       /         \
                    CardList    SearchBox
                      /            \      \
                     /              \      \
                  Child3          Child4   Child5

As we can see, the Parent Node is a key of the tree, so the state should only stay on the App.js;
it shouldn't be passed as an argument into other Child modules or functions. If the state located
on the Parent Node, every time it was changed, the system from the parent node will update
information for all child Nodes. However, for example, the state located on the Search Box,
so the changing of it just only affects its ChildNode like Child4 and Child5, and of course,
this change was not updated for all the systems. This has to be prevented in the React system.
Therefore, the state has to be located in the root of the tree all the time.
